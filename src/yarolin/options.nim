import std/options
export options

import macros

template `?`*[T](ty: typedesc[T]): untyped = Option[T]
  ## Wrap a type inside an ``Option``.
  ##
  ## .. code-block:: nim
  ##
  ##    ?int # same as Option[int]
  ##    ?string # same as Option[string]

macro `or`*[T](opt: Option[T], body: untyped): untyped =
  ## Unpacks the value of ``opt``'s if it has one or get the value of ``body``
  ## instead.
  let optSym = genSym(ident = "opt")
  quote do:
    let `optSym` = `opt`
    if `optSym`.isSome():
      `optSym`.unsafeGet()
    else:
      `body`

macro `<->`*[T](opt1, opt2: sink Option[T]): T =
  ## Unpacks the value of ``opt1`` if it has one and the value of ``opt2``
  ## otherwise.
  let
    opt1Sym = genSym(ident = "opt1")
    opt2Sym = genSym(ident = "opt2")
  quote do:
    let `opt1Sym` = `opt1`
    if `opt1Sym`.isSome():
      `opt1Sym`.unsafeGet()
    else:
      `opt2Sym`.get()

macro mapIt*[T](opt: sink Option[T], body: untyped): untyped =
  ## If ``opt`` has a value, execute ``body`` with the variable ``it`` being
  ## the value of ``opt`` and wrap the value it generates inside an option or
  ## return an empty option otherwise.
  let
    optSym = genSym(ident = "opt")
    tSym = genSym(kind = nskType, ident = "T")
  quote do:
    let `optSym` = `opt`
    if `optSym`.isSome():
      let it {.inject.} = `optSym`.unsafeGet()
      some(`body`)
    else:
      type `tSym` = typeof(block:
        var it {.inject, noinit.}: `optSym`.T
        `body`)
      none(`tSym`)

proc map2*[V1, V2, V3](opt1: Option[V1],
                       opt2: Option[V2],
                       fn: proc(a: V1, b: V2): V3): Option[V3]
                      {.effectsOf: fn.} =

  ## Maps the values of 2 options into another option at the same time. Useful
  ## for calling a function that takes those values or doing an operation
  ## between them without polluting the code with if statements.
  ##
  ## .. code-block:: nim
  ##
  ##    let # Feel free to improve the example :P
  ##      key = env.get("KEY")
  ##      value = env.get("VALUE")
  ##      kvPair = map2(key, value) do (key, value): (key, value)
  if opt1.isSome() and opt2.isSome():
    return some(fn(opt1.unsafeGet(), opt2.unsafeGet()))
  none(V3)

macro map2AB*[V1, V2](opt1: Option[V1],
                      opt2: Option[V2],
                      body: untyped): untyped =
  ## Works like `map2 <#map2,Option[V1],Option[V2],proc(V1,V2)>`_, but
  ## conditionally executes ``body`` when both options have a value with the
  ## variables ``a`` and ``b`` being the respective values of the options. The
  ## value generated by ``body`` is wrapped inside an option and returned.
  ## When one or both options don't have values, an empty option is returned.
  let
    opt1Sym = genSym(ident = "opt1")
    opt2Sym = genSym(ident = "opt2")
    v3Sym = genSym(kind = nskType, ident = "V3")
  quote do:
    let
      `opt1Sym` = `opt1`
      `opt2Sym` = `opt2`
    if `opt1Sym`.isSome() and `opt2Sym`.isSome():
      let
        a {.inject.} = `opt1Sym`.unsafeGet()
        b {.inject.} = `opt2Sym`.unsafeGet()
      some(`body`)
    else:
      type `v3Sym` = typeof(block:
        var
          a {.inject, noinit.}: `opt1Sym`.T
          b {.inject, noinit.}: `opt2Sym`.T
        `body`)
      none(`v3Sym`)

macro `try`*[T](opt: sink Option[T]): untyped =
  ## Return the value of the option if it has one or causes the function inside
  ## which ``try`` is being expanded to return an empty option otherwise.
  let optSym = genSym(ident = "opt")
  quote do:
    let `optSym` = `opt`
    if not `optSym`.isSome():
      return none(result.T)
    `optSym`.unsafeGet()

macro orReturn*[T](opt: sink Option[T], value: untyped): untyped =
  ## Works like `try <#try.m,sinkOption[T]>`_ but instead of causing the function
  ## to return an empty option, it returns the value generated by ``value``.
  let optSym = genSym(ident = "opt")
  quote do:
    let `optSym` = `opt`
    if not `optSym`.isSome():
      return `value`
    `optSym`.unsafeGet()

proc isSomeAnd*[T](opt: Option[T], fn: proc(val: T): bool): bool
                   {.effectsOf: fn.} =
  
  ## If the option has a value, return the boolean value returned by ``fn``
  ## when applied to the option's value. Return false otherwise.
  result = false
  if opt.isSome():
    result = fn(opt.unsafeGet())

macro isSomeAndIt*[T](opt: Option[T], body: untyped): untyped =
  ## Works like `isSomeAnd <#isSomeAnd,Option[T],proc(T)>`_ but conditionally
  ## executes ``body`` instead of calling a function and uses the boolean value
  ## generated by it. ``body`` *MUST* generate a boolean value.
  let optSym = genSym(ident = "opt")
  quote do:
    let `optSym` = `opt`
    if `optSym`.isSome():
      let it {.inject.} = `optSym`.unsafeGet()
      `body`
    else:
      false
